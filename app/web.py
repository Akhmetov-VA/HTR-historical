import streamlit as st
import pandas as pd
#pd.set_option('display.max_columns', None)
import cv2
from PIL import Image, ImageDraw, ImageFont

import numpy as np
import re


import pathlib
from pathlib import Path
import os
from src.predictor import TextRecognizePipeline

import torch
torch.cuda.set_per_process_memory_fraction(0.5, 0)


st.set_page_config(layout="wide")


@st.cache_resource
def load_predictor():
    detection_model_path = "models/detector/best.pt"
    ocr_model_dir_path = "models/recognizer/trocr_ru_pretrain_3epoch"

    ocr_pipeline = TextRecognizePipeline(
        detection_model_path=detection_model_path, ocr_model_dir_path=ocr_model_dir_path
    )
    return ocr_pipeline


############################
TEST_IMAGE = 'app/11227411_doc1.jpg'
ocr_pipeline = load_predictor()

### Main
st.title("Система распознавания рукописных источников для анализа долгосрочных тенденций  формирования и развития человеческого капитала в России")

st.write('''Рукописные исторические данные занимают уникальное и бесценное место в сохранении прошлого. Однако переход к цифровизации приобретает все большее значение по по большому ряду причин.''')
with st.expander("В чем важность оцифровки рукописных исторических данных?"):
    st.write('''
1) **Сохранение**: Рукописные исторические документы, такие как древние манускрипты, письма и дневники, со временем подвержены износу. Оцифровка помогает сохранить эти деликатные материалы, создавая цифровую копию, которую можно хранить и использовать совместно без риска дальнейшего повреждения. Это гарантирует, что будущие поколения смогут получить доступ к этим документам.
         
2) **Доступность**: Одной из наиболее веских причин для оцифровки рукописных исторических данных является повышенная доступность, которую они обеспечивают. Цифровыми копиями можно легко обмениваться, делая историческую информацию доступной для глобальной аудитории. Исследователи, историки и студенты могут получить доступ к этим документам из любого места, что сокращает необходимость физического посещения архивов и библиотек.
         
3) **Возможность поиска и индексации**: Цифровизация обеспечивает эффективную индексацию и поиск исторических данных. Усовершенствованные алгоритмы поиска и тегирование метаданных позволяют пользователям быстро находить конкретную информацию в обширных архивах. Это облегчает историческое исследование, делая его более быстрым и точным.
         
4) **Транскрипция и перевод**: Расшифровка рукописных текстов может быть трудоемким процессом, подверженным ошибкам. Оцифровка помогает точно расшифровывать эти документы, делая их более доступными для более широкой аудитории. Кроме того, это позволяет переводить исторические документы на несколько языков, облегчая межкультурные исследования.
         
5) **Анализ данных**: Цифровые данные поддаются различным вычислительным методам, таким как интеллектуальный анализ данных, анализ текста и искусственный интеллект. Это открывает новые возможности для исторических исследований, позволяя ученым анализировать тенденции, закономерности и корреляции в рамках больших наборов данных.
         
6) **Сохранение исчезающих письменностей**: Многие исторические письмена находятся под угрозой исчезновения из-за неиспользования. Цифровые копии могут помочь сохранить эти письмена и обучать их, гарантируя, что знания о древних системах письма не будут утрачены.
         
7) **Сотрудничество**: Цифровизация облегчает сотрудничество между исследователями, институтами и историками по всему миру. Это поощряет обмен ресурсами, идеями и результатами исследований, способствуя более полному пониманию истории.
         
8) **Защита от стихийных бедствий**: Физические документы уязвимы к стихийным бедствиям и несчастным случаям. Цифровые копии, хранящиеся в нескольких местах, более устойчивы, что снижает риск потери незаменимых исторических данных.
         
9) **Образование**: Оцифрованные исторические данные могут использоваться в образовательных программах, музеях и выставках для ознакомления общественности с их наследием. Это оживляет историю и способствует более глубокому пониманию прошлого.
             ''')
    
st.write("В заключение следует отметить, что важность оцифровки рукописных исторических данных трудно переоценить. Это не только защищает эти ценные артефакты, но и делает их доступными для поиска и анализа, открывая новую эру исторических исследований и понимания. Процесс цифровизации является жизненно важным шагом в сохранении нашего общего культурного и исторического наследия для будущих поколений.")

st.header("Оцифровка исторических рукописных данных с помощью нейронных сетей")

st.image(cv2.imread(TEST_IMAGE), caption='Образец исторического документа')
    
st.write('''
Оцифровка исторических рукописных данных - это попытка сохранить и сделать доступным наше богатое прошлое с помощью современных технологий. Традиционные методы транскрипции могут быть кропотливо медленными и склонными к ошибкам. Однако с появлением нейронных сетей этот процесс стал значительно более эффективным и точным.

Проблема рукописных исторических данных:

Исторические документы, часто написанные архаичными письменами и на хрупких материалах, создают уникальные проблемы. Расшифровка этих документов вручную не только отнимает много времени, но и подвержена человеческим ошибкам. Нейронные сети, подмножество искусственного интеллекта, стали хорошим решением этих проблем.

### Распознавание рукописного ввода

Нейронные сети, в частности сверточные нейронные сети (CNNS) и рекуррентные нейронные сети (RNNS), находятся на переднем крае оцифровки рукописных исторических данных.''')
with st.expander("Вот как обычно работает этот процесс:"):
    st.write('''
1) **Сбор данных** - Первым шагом является накопление существенного набора данных из рукописных исторических документов. Эти документы сканируются или фотографируются для создания цифрового архива. Набор данных должен быть разнообразным, охватывать различные стили и периоды рукописного ввода.
2) **Предварительная обработка** - Рукописный текст часто сопровождается шумом, артефактами старения и вариациями в стилях письма. Методы предварительной обработки, такие как улучшение изображения и шумоподавление, помогают очистить и подготовить данные для обучения нейронной сети.
3) **Обучение нейронной сети** - Нейронная сеть обучается на основе этих предварительно обработанных данных. CNN особенно эффективны при распознавании узоров на изображениях, что делает их пригодными для расшифровки рукописного текста. С другой стороны, RNN отлично справляется с обработкой последовательных данных, что важно для чтения текста.
4) **Распознавание символов** - Во время обучения сеть учится распознавать отдельные символы. Он разбивает рукописный текст на более мелкие фрагменты, что облегчает расшифровку всего текста. Чем на большем количестве данных обучается сеть, тем более точной она становится.
5) **Постобработка** - После того, как нейронная сеть сделала прогнозы, применяются шаги постобработки для повышения точности. Это может включать контекстный анализ, языковое моделирование и алгоритмы исправления ошибок, чтобы гарантировать, что расшифрованный текст является связным и контекстуально точным.
''')


with st.expander("Преимущества оцифровки"):
    st.write('''
1. **Точность**: Нейронные сети обладают значительно более высокими показателями точности по сравнению с ручной транскрипцией. Они могут работать с различными стилями рукописного ввода, даже если шрифт незнакомый или устаревший.
2. **Скорость**: Процесс оцифровки значительно ускоряется. Нейронные сети могут обрабатывать огромные объемы данных за долю времени, которое потребовалось бы человеку-расшифровщику.
3. **Сохранение**: Оцифровка не только делает данные более доступными, но и сохраняет их. Физические документы со временем могут испортиться, но цифровые копии можно сохранять бесконечно долго.
4. **Возможность поиска**: После оцифровки исторические данные становятся доступными для поиска, что позволяет историкам и исследователям эффективно получать доступ к конкретной информации в обширных архивах.
5. **Перевод и анализ**: Оцифрованный текст может быть легко переведен на разные языки, а передовые вычислительные методы могут быть применены для углубленного анализа, выявления тенденций и закономерностей в исторических документах.
''')

st.write('''
Нейронные сети произвели революцию в оцифровке исторических рукописных данных, предложив мощный и эффективный способ раскрыть секреты прошлого. По мере дальнейшего развития технологий этот процесс станет еще более точным и доступным, гарантируя, что наше историческое наследие останется живым и хорошо сохранится для будущих поколений.         ''')
    
st.write('''### Основные функции проекта:

- Загрузка изображений

- Извлечение строк из изображений 

- Построчное аспознавание текста

- Возврат найденых строк и их распознавания
         ''')

st.write('''### Как исползьовать:
         
- В левом блоке есть вкладка для загрузки файлов, туда необходимо загрузить изображение с компьютера.

- После загрузки необходимо нажать кнопку получить предсказание, это запустит процесс детекции строк и распознавания текста

- Обработка может занять до 30 секунд

- Когда обработка закончится вы увидите ниже вкладки 
    - с загруженным изображением
    - найденными строками
    - распознаными в них текстом

- появится возможность скачать файл с распознанным текстом

P.S. если вы не передадите никаких изображений будет использованно тестовое изображение приведенное ранее
''')



### Slidebar
st.sidebar.write("## Загрузка документа для распознавания :gear:")
# Allow multiple file uploads
uploaded_files = st.sidebar.file_uploader("Загрузить файлы (png, jpg, jpeg)", type=["png", "jpg", "jpeg"], accept_multiple_files=True)

process_option = None
if uploaded_files and len(uploaded_files) > 1:
    process_option = st.sidebar.selectbox(
        "Выберите режим обработки",
        ("Обработать все", "Обработать по отдельности", )
    )

if uploaded_files:
    if len(uploaded_files) == 1:
        # Automatically process the single uploaded file
        uploaded_image = uploaded_files[0]
        image = Image.open(uploaded_image)
        st.image(image, caption=f"Загруженное изображение: {uploaded_image.name}", use_column_width=True)

        if st.sidebar.button(f'Распознать {uploaded_image.name}'):
            # Perform recognition for the single file
            cropped_images, recognized_text = ocr_pipeline.recognize(image)

            with st.expander(f'Извлечённый текст для {uploaded_image.name}'):
                for img, text in zip(cropped_images, recognized_text):
                    st.image(img)
                    st.text(text)

            # Download button for recognized text
            st.download_button(f'Скачать результат для {uploaded_image.name}', ' '.join(recognized_text))

    elif process_option == "Обработать по отдельности":
        # Process each file individually
        for uploaded_image in uploaded_files:
            image = Image.open(uploaded_image)
            st.image(image, caption=f"Загруженное изображение: {uploaded_image.name}", use_column_width=True)
            
            if st.sidebar.button(f'Распознать {uploaded_image.name}'):
                # Perform recognition for the selected file
                cropped_images, recognized_text = ocr_pipeline.recognize(image)

                with st.expander(f'Извлечённый текст для {uploaded_image.name}'):
                    for img, text in zip(cropped_images, recognized_text):
                        st.image(img)
                        st.text(text)

                # Download button for recognized text
                st.download_button(f'Скачать результат для {uploaded_image.name}', ' '.join(recognized_text))

    elif process_option == "Обработать все":
        # Process all files at once
        if st.sidebar.button('Распознать все изображения'):
            all_recognized_texts = []

            for uploaded_image in uploaded_files:
                image = Image.open(uploaded_image)
                st.image(image, caption=f"Загруженное изображение: {uploaded_image.name}", use_column_width=True)
                
                # Perform recognition for each file
                cropped_images, recognized_text = ocr_pipeline.recognize(image)
                all_recognized_texts.append(f"Результаты для {uploaded_image.name}:\n{' '.join(recognized_text)}\n")
                
                with st.expander(f'Извлечённый текст для {uploaded_image.name}'):
                    for img, text in zip(cropped_images, recognized_text):
                        st.image(img)
                        st.text(text)

            # Show combined recognized text
            combined_text = '\n'.join(all_recognized_texts)
            st.download_button('Скачать результаты для всех изображений', combined_text)

else:
    st.write("Загрузите изображения для распознавания.")

# Example behavior when no images are uploaded (use test image)
TEST_IMAGE = 'app/11227411_doc1.jpg'
if not uploaded_files:
    st.image(cv2.imread(TEST_IMAGE), caption='Образец исторического документа')

    if st.button('Распознать тестовое изображение'):
        test_image = Image.open(TEST_IMAGE)
        cropped_images, recognized_text = ocr_pipeline.recognize(test_image)

        with st.expander('Извлечённый текст из тестового изображения'):
            for img, text in zip(cropped_images, recognized_text):
                st.image(img)
                st.text(text)

        st.download_button('Скачать результат тестового изображения', ' '.join(recognized_text))
